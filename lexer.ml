# 1 "lexer.mll"
 

(* Ceci sera utile dans le futur quand on aura un parseur qui definit *)
(* les tokens qu'il souhaite recevoir depuis le lexeur.               *)

open Parser 

open Lexing

exception Eof;;
exception LexError;;
let keyword_table = Hashtbl.create 53
let _ =
List.iter (fun (kwd, tok) -> Hashtbl.add keyword_table kwd tok)
[ "begin", BEGIN;
  "end", END;
  "if", IF;
  "then", THEN;
  "else", ELSE;
  "while", WHILE;
  "for", FOR;
  "type", TYPE;
  "function", FUNCTION;
  "var", VAR;
  "and", ANDLET;
  "to", TO;
  "downto", DOWNTO;
  "do", DO;
  "done", DONE;
  "nil", NIL;
  "in", IN;
  "of", OF;
  "array", ARRAY;
];;

let commentlevel = ref 0;;

(* This hack is due to Stefano Zacchiroli *)
let string_unescaped =
  let lex = lazy (Genlex.make_lexer []) in
  fun s ->
    let tok = Lazy.force lex (Stream.of_string ("\"" ^ s ^ "\"")) in
    match Stream.peek tok with
      | Some (Genlex.String s) -> s
      | _ -> assert false



# 51 "lexer.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base = 
   "\000\000\225\255\226\255\227\255\228\255\229\255\230\255\231\255\
    \232\255\233\255\234\255\236\255\237\255\238\255\239\255\240\255\
    \002\000\031\000\247\255\033\000\249\255\250\255\251\255\087\000\
    \162\000\053\000\255\255\254\255\248\255\246\255\244\255\245\255\
    \085\000\253\255\049\000\086\000\255\255\254\255\001\000\255\255\
    \037\000\091\000\092\000\094\000\095\000\255\255\254\255";
  Lexing.lex_backtrk = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \013\000\012\000\255\255\014\000\255\255\255\255\255\255\003\000\
    \002\000\020\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\002\000\002\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\001\000\255\255\255\255";
  Lexing.lex_default = 
   "\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \255\255\255\255\000\000\255\255\000\000\000\000\000\000\255\255\
    \255\255\255\255\000\000\000\000\000\000\000\000\000\000\000\000\
    \033\000\000\000\255\255\255\255\000\000\000\000\038\000\000\000\
    \041\000\255\255\043\000\255\255\255\255\000\000\000\000";
  Lexing.lex_trans = 
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\026\000\026\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \026\000\000\000\004\000\039\000\000\000\000\000\022\000\003\000\
    \010\000\009\000\011\000\013\000\015\000\012\000\020\000\025\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\019\000\014\000\016\000\018\000\017\000\031\000\
    \030\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\006\000\029\000\005\000\028\000\027\000\
    \037\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\008\000\021\000\007\000\023\000\034\000\
    \036\000\042\000\046\000\044\000\035\000\045\000\045\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\000\000\000\000\000\000\000\000\023\000\000\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \001\000\255\255\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\255\255\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\255\255\000\000\000\000\
    \000\000\000\000\000\000\000\000\255\255\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000";
  Lexing.lex_check = 
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\000\000\038\000\255\255\255\255\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\
    \016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\017\000\000\000\019\000\025\000\
    \034\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\023\000\032\000\
    \035\000\040\000\041\000\042\000\032\000\043\000\044\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\255\255\255\255\255\255\255\255\023\000\255\255\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\038\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\040\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\032\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\042\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255";
  Lexing.lex_base_code = 
   "";
  Lexing.lex_backtrk_code = 
   "";
  Lexing.lex_default_code = 
   "";
  Lexing.lex_trans_code = 
   "";
  Lexing.lex_check_code = 
   "";
  Lexing.lex_code = 
   "";
}

let rec token lexbuf =
    __ocaml_lex_token_rec lexbuf 0
and __ocaml_lex_token_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 59 "lexer.mll"
                         (token lexbuf; (* ignore whitespaces *))
# 203 "lexer.ml"

  | 1 ->
# 60 "lexer.mll"
                    (incr commentlevel; comment lexbuf; (*skip over comments *))
# 208 "lexer.ml"

  | 2 ->
# 61 "lexer.mll"
                 (NUM(int_of_string(Lexing.lexeme lexbuf)))
# 213 "lexer.ml"

  | 3 ->
# 62 "lexer.mll"
                 (let id = Lexing.lexeme lexbuf in
		   try
		   Hashtbl.find keyword_table id
		   with Not_found ->
		   IDENT(Lexing.lexeme lexbuf))
# 222 "lexer.ml"

  | 4 ->
# 67 "lexer.mll"
                 (AND;)
# 227 "lexer.ml"

  | 5 ->
# 68 "lexer.mll"
                 (OR;)
# 232 "lexer.ml"

  | 6 ->
# 69 "lexer.mll"
                 (DOT;)
# 237 "lexer.ml"

  | 7 ->
# 70 "lexer.mll"
                 (ASSIGNS;)
# 242 "lexer.ml"

  | 8 ->
# 71 "lexer.mll"
                 (EQUALS;)
# 247 "lexer.ml"

  | 9 ->
# 72 "lexer.mll"
                 (GTEQ;)
# 252 "lexer.ml"

  | 10 ->
# 73 "lexer.mll"
                 (LTEQ;)
# 257 "lexer.ml"

  | 11 ->
# 74 "lexer.mll"
                 (NE;)
# 262 "lexer.ml"

  | 12 ->
# 75 "lexer.mll"
                 (GT;)
# 267 "lexer.ml"

  | 13 ->
# 76 "lexer.mll"
                 (LT;)
# 272 "lexer.ml"

  | 14 ->
# 77 "lexer.mll"
                 (COLON;)
# 277 "lexer.ml"

  | 15 ->
# 78 "lexer.mll"
                 (COMMA;)
# 282 "lexer.ml"

  | 16 ->
# 79 "lexer.mll"
                 (SEMICOLON;)
# 287 "lexer.ml"

  | 17 ->
# 80 "lexer.mll"
                 (PLUS;)
# 292 "lexer.ml"

  | 18 ->
# 81 "lexer.mll"
                 (MINUS;)
# 297 "lexer.ml"

  | 19 ->
# 82 "lexer.mll"
                 (MULT;)
# 302 "lexer.ml"

  | 20 ->
# 83 "lexer.mll"
                 (DIV;)
# 307 "lexer.ml"

  | 21 ->
# 84 "lexer.mll"
                 (LPAR;)
# 312 "lexer.ml"

  | 22 ->
# 85 "lexer.mll"
                 (RPAR;)
# 317 "lexer.ml"

  | 23 ->
# 86 "lexer.mll"
                 (LCURL;)
# 322 "lexer.ml"

  | 24 ->
# 87 "lexer.mll"
                 (RCURL;)
# 327 "lexer.ml"

  | 25 ->
# 88 "lexer.mll"
                 (LSQ;)
# 332 "lexer.ml"

  | 26 ->
# 89 "lexer.mll"
                 (RSQ;)
# 337 "lexer.ml"

  | 27 ->
# 90 "lexer.mll"
                 (string lexbuf;)
# 342 "lexer.ml"

  | 28 ->
# 91 "lexer.mll"
                 (char lexbuf;)
# 347 "lexer.ml"

  | 29 ->
# 92 "lexer.mll"
           (let pos= lexbuf.lex_last_pos in
            let lenleft=lexbuf.lex_buffer_len - pos in
            print_string("Error after position: ");
            print_int (Lexing.lexeme_end lexbuf);
            print_newline();
            let s = lexbuf.lex_buffer in
            print_string("Left:\n---\n"^(String.sub s pos (lenleft))^"\n---\n");
            print_newline();
            raise LexError;)
# 360 "lexer.ml"

  | 30 ->
# 101 "lexer.mll"
             (EOF)
# 365 "lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_token_rec lexbuf __ocaml_lex_state

and comment lexbuf =
    __ocaml_lex_comment_rec lexbuf 32
and __ocaml_lex_comment_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 104 "lexer.mll"
                 (incr commentlevel; comment lexbuf)
# 376 "lexer.ml"

  | 1 ->
# 105 "lexer.mll"
                 (decr commentlevel; 
                  if !commentlevel = 0 then 
                    (* end of comment, resume normal lexing *)
                    token lexbuf
		  else 
                    comment lexbuf)
# 386 "lexer.ml"

  | 2 ->
# 111 "lexer.mll"
            (comment lexbuf;)
# 391 "lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_comment_rec lexbuf __ocaml_lex_state

and string lexbuf =
    __ocaml_lex_string_rec lexbuf 38
and __ocaml_lex_string_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 114 "lexer.mll"
                ((* cette solution ne marche pas s'il y a des "\"" inclus *)
	                 let s =
			   String.sub
			     (Lexing.lexeme lexbuf) 0
			     ((Lexing.lexeme_end lexbuf)
                              - (Lexing.lexeme_start lexbuf) -1) in
			     STRING(string_unescaped s))
# 408 "lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_string_rec lexbuf __ocaml_lex_state

and char lexbuf =
    __ocaml_lex_char_rec lexbuf 40
and __ocaml_lex_char_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 122 "lexer.mll"
                    ( CHAR(match String.get (Lexing.lexeme lexbuf) 1
                           with 'n' -> '\n' 
                              | '\\' -> '\\' 
                              | _ -> failwith "Illegal escape in char expression") )
# 422 "lexer.ml"

  | 1 ->
# 126 "lexer.mll"
                    ( CHAR(String.get (Lexing.lexeme lexbuf) 0)   )
# 427 "lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_char_rec lexbuf __ocaml_lex_state

;;

# 128 "lexer.mll"
 
(* 
let _ =
try
let lexbuf = Lexing.from_channel stdin in
while true do
print_ast(token lexbuf);
(*
print_newline();
print_string "-----";
print_newline();
*)
done
with Eof ->
print_newline();
exit 0
*)

# 452 "lexer.ml"
